<!DOCTYPE html>
<html lang="en">
<head>
    <title>Zircon Standalone</title>
</head>
<body>
<article>
    <header>
        <h3 id="main_title">Zircon Standalone</h3>
    </header>
    <p>
        <a href="https://github.com/fctorial/zircon_standalone">Zircon Standalone</a> is a framework
        for running programs on <a href="https://fuchsia.dev/fuchsia-src/concepts/kernel">the zircon kernel</a>.
        Zircon is the core platform that powers Fuchsia, the upcoming operating system by google.
    </p>
    <p>
        Fuchsia is a work in progress as of today. The only way to run it is to compile it from source from the
        fuchsia source tree. <br/>
        Fuchsia project has the concept of "products". A product defines the software configuration that a build will
        produce. Most critically, a product typically defines the kinds of user experiences that are provided for, such
        as what kind of graphical shell the user might observe, whether or not multimedia support is included, and so
        on.
    </p>
    <h4>Why?</h4>
    <p>
        Main advantages is build time. The smallest fuchsia product is "bringup" and it's 10-20 times bigger than the kernel.
        Building it takes around 30 minutes on a 4 core machine. Zircon Standalone might provice a more pleasant experience
        if you don't have brock lesnar of a pc.
    </p>
    <p>
        It might also be useful if you're trying to run zircon on a resource constrained system. Zircon can boot with
        8mb of ram, and it could be brought down some more by abandoning multiboot (it causes duplication of around 2mb
        of data), but that will require writing a custom bootloader.
    </p>
    <p>
        Fuchsia permission model builds on top of zircon. It locks down some capabilities like process creation behind
        system services. Access to those services is managed by the component framework and capability routing. So a
        regular userspace process that isn't bootsvc (the init process of fuchsia) cannot use the full extent of zircon
        system calls. Zircon
        Standalone allows you to compile and test an init process separate from the fuchsia source tree. The kernel and
        bootloader are built from the fuchsia source tree and you supply the userspace.
    </p>
    <h4>Setup</h4>
    <ol>
        <li>
            Clone the <a>repository</a>.
        </li>
        <li>
            Set the following environment variables:
            <ul>
                <li>
                    <progi>FUCHSIA_DIR</progi>
                    : Fuchsia source root.
                </li>
                <li>
                    <progi>FUCHSIA_OUT</progi>
                    : Fuchsia build output directory.
                </li>
                <li>
                    <progi>TARGET_IS_ARM</progi>
                    : Whether you're compiling for ARM.
                </li>
            </ul>
        </li>
        <li>
            Execute this command:
            <prog class="language-bash">
                fx ninja -C $FUCHSIA_OUT `cat build/deps_x64.txt`
            </prog>
            This will compile the kernel and the bootloader.
        </li>
        <li>
            <prog class="language-bash">
                make && ./build/run_x64.sh
            </prog>
        </li>
    </ol>
    <h4>Dependencies on Fuchsia project</h4>
    <ul>
        <li>
            The init process code depends on zircon headers in
            <progi>//zircon/system/public</progi>
            for type definitions
            and preprocessor constants.
        </li>
        <li>
            The build process uses kernel executable and bootloader executable from the build output directory.
        </li>
        <li>
            <progi>libs/headers/syscall_signatures.h</progi> is generated from a file named <progi>cdecls.inc</progi> that is
            generated by the build system from fidl declarations. You only need to regenerate it if the syscall api changes.
            There's a makefile target for that.
        </li>
    </ul>
    <h4>Building on ARM host</h4>
    <p>
        I don't have an ARM workstation. PRs are welcome for adding support for ARM host. (Preferably as an environment
        variable <progi>HOST_IS_ARM</progi>)
    </p>
</article>
</body>
<script constexpr src="/static/js/constexpr/lib.js"></script>
<script constexpr src="/static/js/constexpr/index.js"></script>
<script constexpr src="/static/js/constexpr/renderer.js"></script>
<script constexpr>
  function watchdog() {
    const bge = document.querySelector('#main_bg')
    if (bge) {
      bge.src = '/static/img/fuchsia.svg'
      finishLoading()
    } else {
      setTimeout(watchdog, 100)
    }
  }
  startLoading()
  watchdog()
</script>
</html>
